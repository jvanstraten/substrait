(*
 * This grammar specifies the language used to describe function overload
 * parameter patterns and the type expressions used to derive the return
 * type in simple extension YAML files.
 *
 * Notes on how to interpret this grammar:
 *
 *  - This grammar assumes that the input has been lowercased before it is
 *    parsed, as the grammar is case-insensitive and this keeps it at least
 *    somewhat clean.
 *  - Some rules in this grammar are ambiguous. Ambiguity must be resolved
 *    by applying the first alternative that matches, while matching ?*+
 *    greedily. This can easily be accomplished using a recursive-descent
 *    parser.
 *  - This grammar is overly strict w.r.t. required whitespace, supported
 *    characters in comments, etc. Implementations may accept a superset of
 *    this grammar, as long as all inputs that are matched by this grammar
 *    are evaluated according to this specification.
 *  - The syntax (*:...* ) is used to specify some functional annotations for
 *    ebnf.py:
 *     - between a rule and its patterns:
 *        - (*:collapse:rule* ): the alternatives for a collapsed rule are
 *          added to the AST node for the specified rule, and said node is
 *          used for both types. The rule that is collapsed into must have
 *          a toplevel alter with just that rule. Used to hide precedence
 *          logic in the AST node types.
 *        - (*:text* ): instead of generating an AST node for this rule, just
 *          store matched text as a string. For systems with a separate lexer
 *          and parser, this is a lexer rule.
 *        - (*:skip* ): same as text, but not included in the AST.
 *        - (*:frag* ): for systems with a separate lexer and parser, this is
 *          a fragment of a token.
 *     - before a toplevel alternative: specifies the name of that alternative.
 *       May be omitted for skipped and text rules, or when the alternative
 *       matches a single literal string (in which case that string is used).
 *)


(**** Toplevel rules ****)

(**
 * Toplevel rule for function parameter type patterns. The argument pack
 * supplied to a function is matched against these parameter type patterns.
 * Variables used in the patterns are assigned by unpacking argument types
 * into them. If this would redefine a variable to a different value, the
 * function overload does not match the supplied argument pack. Note that for
 * any nullability handling methods other than `DISCRETE` the nullability check
 * will be omitted, but the nullability of arguments can still be captured.
 *)
<function_parameter> ::= <newline>? <pattern> <newline>? ;

(**
 * Toplevel rule for function return types. The statements are first evaluated
 * sequentially, from top to bottom. If any error is encountered, the function
 * overload is said to not match the argument pack for which the statements are
 * evaluated. The final expression at the end is evaluated to determine the
 * return type. Note that the computed nullability of the return type will be
 * overridden if `MIRROR` is specified for nullability handling.
 *)
<return_type_program> ::= <newline>? <statement>* <expression> <newline>? ;

(**
 * Statement.
 *)
<statement>

  (**
   * Evaluates the RHS expression, then unpacks the result into the LHS
   * pattern. An error must be thrown (implying that the function does not
   * match the provided argument pack) if:
   *  - the expression cannot be evaluated due to "?" operators, previously
   *    undefined variables, or undefined components of type patterns;
   *  - the result of the RHS expression does not match the pattern on the LHS;
   *    or
   *  - a new value would be unpacked into a previously defined variable on the
   *    LHS, for which the value differs.
   * Variables used in the LHS pattern are assigned by unpacking the result of
   * the RHS expression.
   *)
  ::= (*:assign*) <pattern> <white>? "=" <white>? <expression> <newline>

  (**
   * Asserts that the given expression yields true. An error must be thrown
   * (implying that the function does not match the provided argument pack) if
   * the expression yields anything else. This is useful in particular in
   * conjunction with the "in" expression, to specify constraints.
   *)
    | (*:assert*) "assert" <white> <expression> <newline>
    ;


(**** Expressions ****)

(**
 * An expression, that can be evaluated once all inputs it depends on are
 * defined.
 *)
<expression>

  (**
   * Ternary conditional. The condition expression must yield a boolean. If
   * true, the "then" expression is evaluated and returned. If false, the
   * "else" expression is evaluated and returned.
   *)
  ::= (*:if_else*) <expression> <white>? "?" <white>? <expression> <white>? ":" <white>? <expression>
    | (*:if_else*) "if" <white> <expression> <white> "then" <white> <expression> <white> "else" <white> <expression>

  (**
   * Evaluates the LHS expression, and then matches it against the entries
   * in the set until one of the patterns matches. Any variables used within
   * the matching pattern are defined by unpacking the expression into it, as
   * if it were an assignment statement. If any pattern matches, true is
   * returned, otherwise false is returned. Typically used in conjunction with
   * "assert" statements.
   *)
    | (*:in*) <expression> <white> "in" <white> <metavalue_set>

  (**
   * A boolean OR expression. Both the LHS and RHS must be booleans. The RHS
   * is only evaluated if the LHS yielded false.
   *)
    | (*:or*) <expression1> <white>? "||" <white>? <expression>
    | (*:or*) <expression1> <white> "or" <white> <expression>

(* Next precedence level... *)
    | <expression1>
    ;
<expression1> (*:collapse:expr*)

  (**
   * A boolean AND expression. Both the LHS and RHS must be booleans. The RHS
   * is only evaluated if the LHS yielded true.
   *)
  ::= (*:and*) <expression2> <white>? "&&" <white>? <expression1>
    | (*:and*) <expression2> <white> "and" <white> <expression1>

(* Next precedence level... *)
    | <expression2>
    ;
<expression2> (*:collapse:expr1*)

  (**
   * Equality test. A metatype mismatch between the LHS and RHS is an error.
   *)
  ::= (*:eq*) <expression3> <white>? "==" <white>? <expression2>

  (**
   * Inequality test. A metatype mismatch between the LHS and RHS is an error.
   *)
    | (*:ne*) <expression3> <white>? "!=" <white>? <expression2>

(* Next precedence level... *)
    | <expression3>
    ;
<expression3> (*:collapse:expr2*)

  (**
   * Less-than test. The LHS and RHS must both be integers.
   *)
  ::= (*:lt*) <expression4> <white>? "<" <white>? <expression3>

  (**
   * Less-than-or-equal test. The LHS and RHS must both be integers.
   *)
    | (*:le*) <expression4> <white>? "<=" <white>? <expression3>

  (**
   * Greater-than test. The LHS and RHS must both be integers.
   *)
    | (*:gt*) <expression4> <white>? ">" <white>? <expression3>

  (**
   * Greater-than-or-equal test. The LHS and RHS must both be integers.
   *)
    | (*:ge*) <expression4> <white>? ">=" <white>? <expression3>

(* Next precedence level... *)
    | <expression4>
    ;
<expression4> (*:collapse:expr3*)

  (**
   * Integer addition. The LHS and RHS must both be integers. i64 overflow
   * should throw an error.
   *)
  ::= (*:add*) <expression5> <white>? "+" <white>? <expression4>

  (**
   * Integer subtraction. The LHS and RHS must both be integers. i64 overflow
   * should throw an error.
   *)
    | (*:sub*) <expression5> <white>? "-" <white>? <expression4>

(* Next precedence level... *)
    | <expression5>
    ;
<expression5> (*:collapse:expr4*)

  (**
   * Integer multiplication. The LHS and RHS must both be integers. i64 overflow
   * should throw an error.
   *)
  ::= (*:mul*) <expression6> <white>? "*" <white>? <expression5>

  (**
   * Integer division, rounding down to negative infinity (same convention as
   * Python, NOT the same as C and friends). The LHS and RHS must both be
   * integers. Division by zero should throw an error.
   *)
    | (*:div*) <expression6> <white>? "/" <white>? <expression5>

  (**
   * Integer remainder for the above definition of division (that is, the sign
   * matches the divisor, not the divident). The LHS and RHS must both be
   * integers. Division by zero should throw an error.
   *)
    | (*:rem*) <expression6> <white>? "%" <white>? <expression5>

(* Next precedence level... *)
    | <expression6>
    ;
<expression6> (*:collapse:expr5*)

  (**
   * Integer unity operator, to allow integer literals with explicit positive
   * sign to be specified. The operand must be an integer.
   *)
  ::= (*:pos*) "+" <white>? <expression6>

  (**
   * Integer negation operator. The operand must be an integer. i64 overflow
   * (for an input of -2^63) should throw an error.
   *)
    | (*:neg*) "-" <white>? <expression6>

  (**
   * Boolean NOT operator. The operand must be a boolean.
   *)
    | (*:inv*) "!" <white>? <expression6>

  (**
   * Alternative syntax for "in" expression.
   *)
    | (*:covers*) "covers" <white>? "(" <white>? <expression> <white>? "," <white>? <metavalue_set> <white>? ")"

  (**
   * Built-in function evaluation. The built-in functions are:
   *
   *  - min(int, int) -> int: returns the lowest integer;
   *  - max(int, int) -> int: returns the highest integer;
   *
   * and expressions also have a function form:
   *
   *  - if_else(bool, T, T) -> T: function form of ternary operator;
   *  - or(bool, bool) -> bool: function form of || operator;
   *  - and(bool, bool) -> bool: function form of && operator;
   *  - equal(int, int) -> bool: function form of == operator;
   *  - not_equal(int, int) -> bool: function form of != operator;
   *  - greater_than(int, int) -> bool: function form of > operator;
   *  - greater_equal(int, int) -> bool: function form of >= operator;
   *  - less_than(int, int) -> int: function form of < operator; and
   *  - less_equal(int, int) -> int: function form of <= operator.
   *  - add(int, int) -> int: function form of + operator;
   *  - subtract(int, int) -> int: function form of binary - operator;
   *  - multiply(int, int) -> int: function form of * operator;
   *  - divide(int, int) -> int: function form of / operator;
   *  - remainder(int, int) -> int: function form of % operator;
   *  - positive(int) -> int: function form of unary + operator;
   *  - negate(int) -> int: function form of unary - operator;
   *  - not(bool) -> bool: function form of ! operator;
   *
   * Note that all arguments of a function are evaluated before the function
   * itself is evaluated, so if_else(), or() and and() differ from the
   * expressions in terms of short-circuiting behavior.
   *)
    | (*:fn*) <identifier> <white>? "(" <white>? (<expression> (<white>? "," <white>? <expression>)* <white>?)? ")"

(* Next precedence level... *)
    | <parenthesized_expression>
    ;
<parenthesized_expression> (*:collapse:expr6*)

  (**
   * Parentheses for explicit precedence and escaping otherwise ambiguous
   * syntax.
   *)
  ::= (*:expr*) "(" <white>? <expression> <white>? ")"

  (**
   * Integer literal. Must be within 0..2^63-1. Negative integers are made
   * using the unary "-" operator. There is no literal for -2^63, but this is
   * unlikely to be needed in practice, since there are no bit manipulation
   * functions. If needed, however, it can however be made using for example
   * -9223372036854775807 - 1.
   *)
    | (*:int*) <integer_literal>

  (**
   * Boolean literal.
   *)
    | (*:bool*) <boolean_literal>

  (**
   * Fully-specified patterns (i.e. previously defined variables and
   * fully-specified types) may be used like a literal.
   *)
    | (*:patt*) <pattern>
    ;

(**
 * A pattern. Used to match types and unpack type parameters.
 *)
<pattern>

  (**
   * When used as a pattern, this matches a data type. All expression rules
   * matched within a pattern must also be valid patterns (no functions or
   * operators must be used). When used in an expression, this must yield a
   * fully-defined type, i.e. any variables used must have previously been
   * defined, and "?" operators are not allowed.
   *)
  ::= (*:type*) <data_type>

  (**
   * Variable usage (when used within an expression) or definition (when
   * used within a pattern). When used within an expression, the variable
   * must have previously been assigned. When used within a pattern, the
   * variable must either not have been assigned yet (it is then treated
   * as a template within the pattern), or must have been assigned to the
   * exact same value (it is treated as part of the pattern).
   *)
    | (*:var*) <identifier>

  (**
   * Operator that behaves like a variable that is never actually assigned,
   * or, equivalently, it matches everything. May only be used in pattern
   * context.
   *)
    | (*:any*) "?"
    ;

(**
 * A set of possible values, used by the "in" expression to define
 * constraints.
 *)
<metavalue_set>

  (**
   * Shorthand notation for a set consisting of a single element or integral
   * range.
   *)
  ::= (*:single*) <metavalue_set_element>

  (**
   * A set consisting of one or more values. The elements are matched from
   * left to right, and only the first matching element (if multiple match)
   * is unpacked into variables.
   *)
    | (*:multi*) "[" <white>? <metavalue_set_element> (<white>? "," <white>? <metavalue_set_element>)* <white>? "]"
    ;

(**
 * A set "element", either a single value, a single pattern, or a range of
 * integers.
 *)
<metavalue_set_element>

  (**
   * A single value or pattern.
   *)
  ::= (*:single*) <expression>

  (**
   * An inclusive range of integers. If the LHS is greater than the RHS, the
   * range does not match anything.
   *)
    | (*:range*) <expression> <white>? ".." <white>? <expression>
    ;


(**** Type literals and patterns ****)

(**
 * A type pattern or literal.
 *)
<data_type> ::= <type_class> <white>? <nullability> <white>? <type_variation> <white>? <parameter_pack>? ;

(**
 * The type class, either a builtin type or a user-defined type. Note that
 * the builtin types must be specified here verbatim, because otherwise this
 * rule would conflict with variable usage.
 *)
<type_class>

  (**
   * Builtin simple types. <parameter_pack> must be left unspecified.
   *)
  ::= "boolean"
    | "i8"
    | "i16"
    | "i32"
    | "i64"
    | "fp32"
    | "fp64"
    | "string"
    | "binary"
    | "timestamp"
    | "timestamp_tz"
    | "date"
    | "time"
    | "interval_year"
    | "interval_day"
    | "uuid"

  (**
   * Builtin complex types. When <parameter_pack> is left unspecified, types with any
   * number of parameters are matched.
   *)
    | "fixedchar"
    | "varchar"
    | "fixedbinary"
    | "varbinary"
    | "decimal"
    | "struct"
    | "nstruct"
    | "list"
    | "map"

  (**
   * A user-defined type defined in the current simple extension. Since (at the
   * time of writing) user-defined types cannot declare parameters, <parameter_pack>
   * must be left unspecified.
   *)
    | (*:user*) "u!" <identifier>

  (**
   * A user-defined type defined in another simple extension. The first
   * identifier must match a namespace defined elsewhere in the YAML file,
   * mapping it to the canonical URI of the extension (URI syntax would
   * otherwise conflict with this grammar). Since (at the time of writing)
   * user-defined types cannot declare parameters, <parameter_pack> must be left
   * unspecified.
   *)
    | (*:user_ext*) "u!" <identifier> "." <identifier>
    ;

(**
 * The nullability of a type.
 *)
<nullability>

  (**
   * The type is nullable when the ? is present, otherwise it is required.
   * When this type is used as a pattern for a function argument type, and
   * the function's nullability handling method is set to anything other
   * than `DISCRETE`, this is ignored.
   *)
  ::= (*:literal*) "?"?

  (**
   * Nullability is captured into a variable or ignored in case of a pattern,
   * or specified by means of a boolean expression. Note that ignored
   * nullability will look like for example "i32??".
   *)
    | (*:expression*) "?" <white>? <parenthesized_expression>
    ;

(**
 * The variation of a type.
 *)
<type_variation>

  (**
   * Use the system-default variation.
   *)
  ::= (*:base*) ("[" <white>? "0" <white>? "]")?

  (**
   * Use the specified variation from this extension.
   *)
    | (*:user*) "[" <white>? <identifier> <white>? "]"

  (**
   * Use the specified variation from another extension, referred to by the
   * prefixed namespace (same logic as for base types).
   *)
    | (*:user_ext*) "[" <white>? <identifier> "." <identifier> <white>? "]"

  (**
   * Match any variation. May only be used within a pattern.
   *)
    | (*:any*) "[" <white>? "?" <white>? "]"
    ;

(**
 * The parameter pack of a compound type.
 *)
<parameter_pack> ::= "<" <white>? (<parameter> (<white>? "," <white>? <parameter>)* <white>?)? ">" ;

(**
 * A single type parameter.
 *)
<parameter>

  (**
   * Syntax for a named parameter. The name is semantically ignored; the syntax
   * is allowed only for symmetry with the NSTRUCT pseudotype. For simplicity,
   * implementations may choose to accept or reject named parameters outside the
   * context of an NSTRUCT and anonymous parameters within the context of an
   * NSTRUCT, rendering this merely a grammatical construct.
   *)
  ::= (*:named*) <identifier> <white>? ":" <white>? <expression>

  (**
   * Syntax for an anonymous/unnamed parameter.
   *)
    | (*:anon*) <expression>
    ;


(**** Simple literals and identifiers ****)

(**
 * Positive integer. Only base 10 is supported at this time.
 *)
<integer_literal> (*:text*) ::= [1-9] [0-9]* ;

(**
 * Boolean literals.
 *)
<boolean_literal> ::= "true" | "false" ;

(**
 * An arbitrary identifier for as far as parsing is concerned. Used for all
 * kinds of things.
 *)
<identifier> (*:text*) ::= <identifier_start> <identifier_continuation>* ;

(**
 * Permissible initial characters of an identifier.
 *)
<identifier_start> (*:frag*) ::= [a-z] | [A-Z] | "_" | "$" ;

(**
 * Subsequent characters of an identifier.
 *)
<identifier_continuation> (*:frag*) ::= [a-z] | [A-Z] | [0-9] | "_" | "$" ;


(**** Whitespace and comment management ****)

(**
 * A grammatically required newline.
 *)
<newline> (*:skip*) ::= <white>? (<single_newline> <white>?)+ ;

(**
 * Grammatically required spacing.
 *)
<white> (*:skip*) ::= <single_space>+ ;

(**
 * A single newline, possibly including an end-of-line comment. Both # and //
 * are allowed as start characters.
 *)
<single_newline> (*:frag*) ::= <line_comment>? ( "\n" | "\r" | "\r" "\n" ) ;

(**
 * A single spacing character or C-style block comment.
 *)
<single_space> (*:frag*) ::= " " | "\t" | <block_comment> ;

(**
 * An optional end-of-line comment. Both # and // are allowed as start
 * characters.
 *)
<line_comment> (*:frag*) ::= "//" <not_newline>* | "#" <not_newline>* ;

(**
 * A C-style block comment.
 *)
<block_comment> (*:frag*) ::= "/*" <block_comment_character>* "*"? "*/" ;

(**
 * A single token in a block comment, either a single character or an asterisk
 * followed by something that isn't a slash.
 *)
<block_comment_character> (*:frag*) ::= <not_asterisk> | "*" <not_slash> ;

(**
 * Any single character supported on the input, except for newlines.
 *)
<not_newline> (*:frag*) ::= <not_newline_asterisk_or_slash> | "*" | "/" ;

(**
 * Any single character supported on the input, except for asterisks.
 *)
<not_asterisk> (*:frag*) ::= <not_newline_asterisk_or_slash> | "\n" | "\r" | "/" ;

(**
 * Any single character supported on the input, except for slashes.
 *)
<not_slash> (*:frag*) ::= <not_newline_asterisk_or_slash> | "\n" | "\r" | "*" ;

(**
 * Any single character supported on the input, except for newlines, asterisks,
 * and slashes. This includes all characters (except aforementioned) that can
 * be written using a US keyboard. Implementations may choose to accept more
 * (or all) characters, but must accept at least this set.
 *)
<not_newline_asterisk_or_slash> (*:frag*)
  ::= [a-z] | [A-Z] | [0-9]
    | " " | "`" | "~" | "!" | "@" | "#" | "$" | "%" | "\t"
    | "^" | "&" | "(" | ")" | "-" | "_" | "=" | "+" | "\""
    | "[" | "{" | "]" | "}" | "|" | ";" | ":" | "'" | "\\"
    | "," | "<" | "." | ">" | "?"
    ;
